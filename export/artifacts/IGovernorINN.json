{
  "contractName": "IGovernorINN",
  "sourceName": "src/contracts/IGovernorINN.sol",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "proposalId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "validatorEOA",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenOffer",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "offchainID",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "description",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "startupName",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "sharedStake",
          "type": "uint16"
        }
      ],
      "name": "ExitInvestmentProposalCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "proposalId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "offchainID",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "description",
          "type": "bytes32"
        }
      ],
      "name": "FreezeInvestmentProposalCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "proposalID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "startupEOA",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenOffer",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "offchainID",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "description",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "startupName",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "sharedStake",
          "type": "uint16"
        }
      ],
      "name": "NewInvestmentProposalCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "proposalID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "validatorEOA",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "offchainID",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "description",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "validatorName",
          "type": "string"
        }
      ],
      "name": "NewValidatorProposalCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "proposalId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "ProposalCanceled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "proposalId",
          "type": "uint256"
        }
      ],
      "name": "ProposalExecuted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "proposalID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "offchainID",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "description",
          "type": "bytes32"
        }
      ],
      "name": "UnfreezeInvestmentProposalCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "voter",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "proposalId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "enum IGovernorINN.VoteType",
          "name": "vote",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "VoteCast",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "proposalId",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "cancel",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "reason",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "proposalId",
          "type": "uint256"
        },
        {
          "internalType": "enum IGovernorINN.VoteType",
          "name": "vote",
          "type": "uint8"
        }
      ],
      "name": "castVote",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "proposalId",
          "type": "uint256"
        }
      ],
      "name": "execute",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "proposalId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "hasVoted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "offchainID",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "descriptionHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "startedAt",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "internalType": "enum IGovernorINN.ProposalType",
          "name": "propsalType",
          "type": "uint8"
        },
        {
          "internalType": "enum IGovernorINN.ActionType",
          "name": "actionType",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "hashProposal",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "offchainID",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "startAt",
              "type": "uint256"
            },
            {
              "internalType": "enum IGovernorINN.ProposalType",
              "name": "proposalType",
              "type": "uint8"
            },
            {
              "internalType": "enum IGovernorINN.ActionType",
              "name": "actionType",
              "type": "uint8"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct IGovernorINN.ProposalRequest",
          "name": "proposalRequest",
          "type": "tuple"
        }
      ],
      "name": "propose",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "proposalId",
          "type": "uint256"
        }
      ],
      "name": "state",
      "outputs": [
        {
          "internalType": "enum IGovernorINN.ProposalState",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "bytecode": "0x",
  "deployedBytecode": "0x",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "events": {
      "ExitInvestmentProposalCreated(uint256,address,address,uint256,bytes32,bytes32,string,uint16)": {
        "details": "Emitted when a ExitInvestment proposal is created."
      },
      "FreezeInvestmentProposalCreated(uint256,address,address,bytes32,bytes32)": {
        "details": "Emitted when a FreezeAccount proposal is created."
      },
      "NewInvestmentProposalCreated(uint256,address,address,uint256,bytes32,bytes32,string,uint16)": {
        "details": "Emitted when a NewInvestment proposal is created."
      },
      "NewValidatorProposalCreated(uint256,address,address,bytes32,bytes32,string)": {
        "details": "Emitted when a NewValidator proposal is created."
      },
      "ProposalCanceled(uint256,string)": {
        "details": "Emitted when a proposal is canceled."
      },
      "ProposalExecuted(uint256)": {
        "details": "Emitted when a proposal is executed. TODO work on Event"
      },
      "UnfreezeInvestmentProposalCreated(uint256,address,address,bytes32,bytes32)": {
        "details": "Emitted when a UnfreezeAccount proposal is created."
      },
      "VoteCast(address,uint256,uint8,string)": {
        "details": "Emitted when a VoteCast created."
      }
    },
    "kind": "dev",
    "methods": {
      "cancel(uint256,string)": {
        "details": "Cancel a proposal. Cancels a proposal only if sender is the proposer. We need to decide to conditions of consensus cancelation Emits a {ProposalCanceled} event."
      },
      "castVote(string,uint256,uint8)": {
        "details": "Cast a vote Emits a {VoteCast} event."
      },
      "execute(uint256)": {
        "details": "Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the deadline to be reached. Emits a {ProposalExecuted} event."
      },
      "hasVoted(uint256,address)": {
        "details": "Returns weither `account` has cast a vote on `proposalId`."
      },
      "hashProposal(bytes32,bytes32,uint256,address,uint8,uint8,bytes)": {
        "details": "Hashing function used to (re)build the proposal id from the proposal ..."
      },
      "name()": {
        "details": "Name of the governor instance (used in building the ERC712 domain separator)."
      },
      "propose((bytes32,uint256,uint8,uint8,string,bytes))": {
        "details": "Create a new proposal. Emits a {ProposalCreated} event."
      },
      "state(uint256)": {
        "details": "Current state of a proposal, following Compound's convention"
      },
      "version()": {
        "details": "Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\""
      }
    },
    "version": 1
  },
  "evm": {
    "bytecode": {
      "functionDebugData": {},
      "generatedSources": [],
      "linkReferences": {},
      "object": "",
      "opcodes": "",
      "sourceMap": ""
    },
    "deployedBytecode": {
      "functionDebugData": {},
      "generatedSources": [],
      "immutableReferences": {},
      "linkReferences": {},
      "object": "",
      "opcodes": "",
      "sourceMap": ""
    },
    "gasEstimates": null,
    "methodIdentifiers": {
      "cancel(uint256,string)": "1536f472",
      "castVote(string,uint256,uint8)": "31cb9866",
      "execute(uint256)": "fe0d94c1",
      "hasVoted(uint256,address)": "43859632",
      "hashProposal(bytes32,bytes32,uint256,address,uint8,uint8,bytes)": "c4865b0f",
      "name()": "06fdde03",
      "propose((bytes32,uint256,uint8,uint8,string,bytes))": "7005026b",
      "state(uint256)": "3e4f49e6",
      "version()": "54fd4d50"
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.14+commit.80d49f37\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validatorEOA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenOffer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"offchainID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"description\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"startupName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"sharedStake\",\"type\":\"uint16\"}],\"name\":\"ExitInvestmentProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"offchainID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"description\",\"type\":\"bytes32\"}],\"name\":\"FreezeInvestmentProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"startupEOA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenOffer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"offchainID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"description\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"startupName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"sharedStake\",\"type\":\"uint16\"}],\"name\":\"NewInvestmentProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validatorEOA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"offchainID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"description\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"validatorName\",\"type\":\"string\"}],\"name\":\"NewValidatorProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"ProposalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"offchainID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"description\",\"type\":\"bytes32\"}],\"name\":\"UnfreezeInvestmentProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IGovernorINN.VoteType\",\"name\":\"vote\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"enum IGovernorINN.VoteType\",\"name\":\"vote\",\"type\":\"uint8\"}],\"name\":\"castVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"offchainID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"descriptionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"enum IGovernorINN.ProposalType\",\"name\":\"propsalType\",\"type\":\"uint8\"},{\"internalType\":\"enum IGovernorINN.ActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"hashProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"offchainID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"startAt\",\"type\":\"uint256\"},{\"internalType\":\"enum IGovernorINN.ProposalType\",\"name\":\"proposalType\",\"type\":\"uint8\"},{\"internalType\":\"enum IGovernorINN.ActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IGovernorINN.ProposalRequest\",\"name\":\"proposalRequest\",\"type\":\"tuple\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum IGovernorINN.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"ExitInvestmentProposalCreated(uint256,address,address,uint256,bytes32,bytes32,string,uint16)\":{\"details\":\"Emitted when a ExitInvestment proposal is created.\"},\"FreezeInvestmentProposalCreated(uint256,address,address,bytes32,bytes32)\":{\"details\":\"Emitted when a FreezeAccount proposal is created.\"},\"NewInvestmentProposalCreated(uint256,address,address,uint256,bytes32,bytes32,string,uint16)\":{\"details\":\"Emitted when a NewInvestment proposal is created.\"},\"NewValidatorProposalCreated(uint256,address,address,bytes32,bytes32,string)\":{\"details\":\"Emitted when a NewValidator proposal is created.\"},\"ProposalCanceled(uint256,string)\":{\"details\":\"Emitted when a proposal is canceled.\"},\"ProposalExecuted(uint256)\":{\"details\":\"Emitted when a proposal is executed. TODO work on Event\"},\"UnfreezeInvestmentProposalCreated(uint256,address,address,bytes32,bytes32)\":{\"details\":\"Emitted when a UnfreezeAccount proposal is created.\"},\"VoteCast(address,uint256,uint8,string)\":{\"details\":\"Emitted when a VoteCast created.\"}},\"kind\":\"dev\",\"methods\":{\"cancel(uint256,string)\":{\"details\":\"Cancel a proposal. Cancels a proposal only if sender is the proposer. We need to decide to conditions of consensus cancelation Emits a {ProposalCanceled} event.\"},\"castVote(string,uint256,uint8)\":{\"details\":\"Cast a vote Emits a {VoteCast} event.\"},\"execute(uint256)\":{\"details\":\"Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the deadline to be reached. Emits a {ProposalExecuted} event.\"},\"hasVoted(uint256,address)\":{\"details\":\"Returns weither `account` has cast a vote on `proposalId`.\"},\"hashProposal(bytes32,bytes32,uint256,address,uint8,uint8,bytes)\":{\"details\":\"Hashing function used to (re)build the proposal id from the proposal ...\"},\"name()\":{\"details\":\"Name of the governor instance (used in building the ERC712 domain separator).\"},\"propose((bytes32,uint256,uint8,uint8,string,bytes))\":{\"details\":\"Create a new proposal. Emits a {ProposalCreated} event.\"},\"state(uint256)\":{\"details\":\"Current state of a proposal, following Compound's convention\"},\"version()\":{\"details\":\"Version of the governor instance (used in building the ERC712 domain separator). Default: \\\"1\\\"\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/IGovernorINN.sol\":\"IGovernorINN\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableMap.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSetUpgradeable.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\\n */\\nlibrary EnumerableMapUpgradeable {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSetUpgradeable.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function get(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        AddressToUintMap storage map,\\n        address key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        AddressToUintMap storage map,\\n        address key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n    }\\n}\\n\",\"keccak256\":\"0x44183e3aa61358ae381c27fa837010552ba90f66d620cf1ba6544f567caa7f3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x1976ce0aadaa551a0fecab9930a7f4956252fa40594c8d165f682020f0e826c0\",\"license\":\"MIT\"},\"src/contracts/IGovernorINN.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol\\\";\\n\\ninterface IGovernorINN {\\n    /**\\n     * @dev Enum type of votes\\n     */\\n    enum VoteType {\\n        NONE,\\n        AGAINST,\\n        FOR,\\n        ABSTAIN\\n    }\\n\\n    /**\\n     * @dev Enum type of proposals\\n     */\\n    enum ProposalType {\\n        NONE,\\n        VALIDATOR,\\n        INVESTMENT,\\n        GOVERNANCE\\n    }\\n\\n    /**\\n     * @dev Enum type of actions\\n     */\\n    enum ActionType {\\n        NONE,\\n        NEW,\\n        EXIT,\\n        FREEZE,\\n        UNFREEZE\\n    }\\n\\n    /**\\n     * @dev Enum state of consensus proposal\\n     */\\n    enum ProposalState {\\n        NONE,\\n        PENDING, //\\n        ACTIVE,\\n        CANCELED,\\n        DEFEATED, // < 51\\n        SUCCEEDED, //51 >\\n        EXPIRED,\\n        EXECUTED\\n    }\\n\\n    /**\\n     * @dev Struct request for proposal creation\\n     */\\n    struct ProposalRequest {\\n        bytes32 offchainID;\\n        uint256 startAt;\\n        ProposalType proposalType;\\n        ActionType actionType;\\n        string description;\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Struct New Validator Proposal\\n     */\\n    struct NewValidatorProposal {\\n        string validatorName;\\n        address validatorEOA;\\n    }\\n\\n    /**\\n     * @dev Struct New Investment Proposal\\n     */\\n    struct NewInvestmentProposal {\\n        string startupName;\\n        uint256 tokenOffer;\\n        address startupEOA;\\n        uint16 sharedStake;\\n    }\\n\\n    /**\\n     * @dev Struct Exit Investment Proposal\\n     */\\n    struct ExitInvestmentProposal {\\n        string startupName;\\n        uint256 tokenOffer;\\n        address validatorEOA; // validator same as a proposer ???? if true should remove validatorEOA\\n        uint16 sharedStake;\\n    }\\n\\n    /**\\n     * @dev Struct Freeze Investment Proposal\\n     */\\n    struct FreezeInvestmentProposal {\\n        address account;\\n    }\\n\\n    /**\\n     * @dev Struct Unfreeze Investment Proposal\\n     */\\n    struct UnfreezeInvestmentProposal {\\n        address account;\\n    }\\n\\n    /**\\n     * @dev Emitted when a NewValidator proposal is created.\\n     */\\n    event NewValidatorProposalCreated(\\n        uint256 indexed proposalID,\\n        address indexed proposer,\\n        address indexed validatorEOA,\\n        bytes32 offchainID,\\n        bytes32 description,\\n        string validatorName\\n    );\\n\\n    /**\\n     * @dev Emitted when a NewInvestment proposal is created.\\n     */\\n    event NewInvestmentProposalCreated(\\n        uint256 indexed proposalID,\\n        address indexed proposer,\\n        address indexed startupEOA,\\n        uint256 tokenOffer,\\n        bytes32 offchainID,\\n        bytes32 description,\\n        string startupName,\\n        uint16 sharedStake\\n    );\\n\\n    /**\\n     * @dev Emitted when a ExitInvestment proposal is created.\\n     */\\n    event ExitInvestmentProposalCreated(\\n        uint256 indexed proposalId,\\n        address indexed proposer,\\n        address indexed validatorEOA,\\n        uint256 tokenOffer,\\n        bytes32 offchainID,\\n        bytes32 description,\\n        string startupName,\\n        uint16 sharedStake\\n    );\\n\\n    /**\\n     * @dev Emitted when a FreezeAccount proposal is created.\\n     */\\n    event FreezeInvestmentProposalCreated(\\n        uint256 indexed proposalId,\\n        address indexed proposer,\\n        address indexed account,\\n        bytes32 offchainID,\\n        bytes32 description\\n    );\\n\\n    /**\\n     * @dev Emitted when a UnfreezeAccount proposal is created.\\n     */\\n    event UnfreezeInvestmentProposalCreated(\\n        uint256 indexed proposalID,\\n        address indexed proposer,\\n        address indexed account,\\n        bytes32 offchainID,\\n        bytes32 description\\n    );\\n\\n    /**\\n     * @dev Emitted when a VoteCast created.\\n     */\\n    event VoteCast(address indexed voter, uint256 indexed proposalId, VoteType vote, string reason);\\n\\n    /**\\n     * @dev Emitted when a proposal is executed.\\n     * TODO work on Event\\n     */\\n    event ProposalExecuted(uint256 indexed proposalId);\\n\\n    /**\\n     * @dev Emitted when a proposal is canceled.\\n     */\\n    event ProposalCanceled(uint256 indexed proposalId, string reason);\\n\\n    /**\\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\\n     * deadline to be reached.\\n     *\\n     * Emits a {ProposalExecuted} event.\\n     *\\n     */\\n    function execute(uint256 proposalId) external payable returns (bool);\\n\\n    /**\\n     * @dev Cancel a proposal. Cancels a proposal only if sender is the proposer.\\n     * We need to decide to conditions of consensus cancelation\\n     *\\n     * Emits a {ProposalCanceled} event.\\n     *\\n     */\\n    function cancel(uint256 proposalId, string memory reason) external returns (bool);\\n\\n    /**\\n     * @dev Create a new proposal.\\n     * Emits a {ProposalCreated} event.\\n     */\\n    function propose(ProposalRequest memory proposalRequest) external returns (uint256);\\n\\n    /**\\n     * @dev Cast a vote\\n     * Emits a {VoteCast} event.\\n     */\\n    function castVote(\\n        string calldata reason,\\n        uint256 proposalId,\\n        VoteType vote\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Returns weither `account` has cast a vote on `proposalId`.\\n     */\\n    function hasVoted(uint256 proposalId, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Current state of a proposal, following Compound's convention\\n     */\\n    function state(uint256 proposalId) external view returns (ProposalState);\\n\\n    /**\\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \\\"1\\\"\\n     */\\n    function version() external view returns (string memory);\\n\\n    /**\\n     * @dev Hashing function used to (re)build the proposal id from the proposal ...\\n     */\\n    function hashProposal(\\n        bytes32 offchainID,\\n        bytes32 descriptionHash,\\n        uint256 startedAt,\\n        address proposer,\\n        ProposalType propsalType,\\n        ActionType actionType,\\n        bytes calldata data\\n    ) external pure returns (uint256);\\n}\\n\",\"keccak256\":\"0xebb81920541c4b8a0f0405e70ce1fff31f36bb51dfe7e5516639e43d3fb4a11b\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  }
}